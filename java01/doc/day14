# day14

Quiz ]
	예외처리의 목적은? 
	==> 프로그램의 정상적인 종료...
예외처리
	==> 프로그램적으로는 문제가 없으나( <== 문법상 오류가 없으나...)
		데이터의 문제나 장비의 문제 등에 의해서 프로그램을 실행하는 도중 발생하는 에러를 
			"실행 에러(Run time Error)"라고 표현하고
			이것을 자바에서는 "예외(Exception)" 이라고 부른다.
			
			문제는 
			이런 예외는 개발자가 예측해서 
			이런 문제가 방생했을 경우 대처하는 방식으로 프로그램을 제작을 해야하고
			이처럼 예외가 발생했을 경우 대처하는 방식의 프로그램을 
				"예외 처리 "
			라고 말한다.
			
		자바에서는 이런 문제점(예외가 발생하는 원인을 개발자가 알고 있어야 한다.)
		을 해결하기 위해서 예외 처리 문법이 존재한다
		
		형식 ] 
			
			(1)
			try{
			(2)
			실행문
			(3)
			} catch(#####) {
				(4)
			} Finally {
				(5)
			}
			(6)
			
			실행순서 ] 
				실행문이 에러가 안날 경우 : 1 --> 2 --> 3 --> 5 --> 6
				실행문이 에러가 날 경우 : 1 --> 2 --> 4 --> 5 --> 6
				
		
		문제점 ]
			(3) 이 문제인데
			 이 부분에 있는 내용은 예외가 발생하면 실행되지 않는다.
			 따라서 try{}의 범위에 따라서 실행 할 수 있고 실행되지 않을 수도 있다.
			 
		예를 1] 
			try {
				파일을 오픈하고  ==> 파일이 없으면 에러가 난다.
			}
			
			파일 내용을 읽는 명령  ==> 이 경우에 파일의 오픈 여부에 따라서 
								읽는 명령도 실행 여부가 판단이 되므로 다시 에러가 발생할 수 있다.
								
		예 2 ]
			try {					-1
				while(true){		
					try{			-2
						클라이언트의 접속을 받는 명령 ==> 클라이언트의 문제로 예외가 발생할 수 있다.
					} 				 2 클라이언트의 접속을 받는다.
				}					1. 다시는 클라리언트의 접속을 받지 않는다.
			}					
			
		자바의 예외처리의 원리
			예외가 발생하면 JVM은 발생한 예외의 종류를 분석한 후
			예외에 대한 정보를 자바스럽게 클래스로 만들어서
			catch부분에 그 클래스의 주소를 전달해 준다.
			
	catch의 의미
		==> 예외가 발생하면 그 예외의 정보를 받아서
			개발자가 그 정보를 이용햇 원하는 처리를 해줘야 한다.
			
	다중 catch ( 참고로 if - else if - else 구문 참고)
		==> 
			try{} 안에 여러명령행 들이 여러가지 복합적인 예외 발생 요소를 가질 수 있다.
			
			이 때 반드시 어떤 에러 때문인지를 구분해야 한다면??/
			이런 경우를 대비해서 만들어 놓은 방법이다.
			
	형식 ] 
		try {
		
		} catch(###) {
		
		} catch(###) {
		
		} catch(###) {
		
		}
		
	주의 사항 ] 
		다중 catch를 사용하는 경우
		반드시 실행 될 수 있는 상태로 만들어야 한다,
		==> 예외의 밤위가 좁은 쪽부터 기술해야 한다.
		
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
문제 2 ]
	
	if - else if 구문을 이용해서 
	
	나이를 입력하면 십대, 이십대, ...
	판별해주는 프로그램을 작성하세요.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
finally 블럭
	==> 예외 발생 여부에 관계없이 반드시 실행 되어야 할 명령이 존재 할 경우
		이런 문장들을 입력하는 블럭
		
	참고 ]
		만약 finally 블럭이 존재한다면 catch블럭을 생략해도 무방하다.
		(실제 실무에서는 catch 블럭을 생략안한다.)
		
예외 정보 출력하기
	==>다음 이유에 의해서 예외 정보를 얻을 수 있다.
	
	1. 예외 정보 클래스의 변수를 출력하면 된다.
	
		예 ]
			System.out.println(예외 정보 클래스 변수);
			==> 예외의 원인을 파악할 수 있게 된다.
			
	2. 변수.printStackTrace()를 이용하는 방법
		==> 예외의 정보 + 예외가 발생하게 된 위치와 경로를 추적해서
			출력해준다.
			
	
	우리가 앞에서 예외처리는
	예외가 발생하면 개발자가 그것을 수정해서
	정상적으로 동작하도록 만드는 행위라고 정의 했다.
	하지만 정성적으로 동작하도록 만드는 행위를 한다는 것은
	매우 어려운 일이며, 그 경우는 많지 않다.
	
	다만 예외를 하는 실제 이유는
	예외 정보를 알아서 사용자에게 왜 프로그램에 문제가 생겼는지  알려주고
	그 프로그램을 정상적으로 종료 되도록 하는 것이 목적으로 갖는 경우가 많다. 

----------------------------------------------------------------------------------------------------------------------------------------------------------
예외 전이 하기
	==> 함수는 프로그램의 가장 작은 단위로 한가지 작업을 하기 위해서 만드는  것이다.
		따라서 함수 안에서 작업을 하다가 예외가 발생하면 
		그 함수는 더이상 실행할 필요가 없는 경우가 많다.
		
		따라서 함수는 예외를 전이하도록 해 놓은 경우가 있다.  
		
		형식 ] 
			
			[접근지정자] [속성] 데이터타입 함수이름(매개변수리스트)	throws 예외클래스1, 예외클래스2, ... {
			}
			
			의미 ] 
				지정한 예외가 발생하면 이 함수는 더이상 실행해도 의미가 없으므로 실행을 중지시킨다.
				
	*****
	예외가 전이딘 함수는
	그 함수를 사용하는 곳에서 반드시 예외처리를 해줘야한다.
	
	참고 ]
		==> 어떤 함수가 예외를 전이하는 함수라도
			예외처리를 하지 안하아도 되는 경우가 있다.
			
			전이하는 예외가 RumtimeException의 하위인경우 예외처리를 해도 그만 안해도 그만이다.
			(주로 java.lang 패키지 소속 클래스에 있는 함수들이 이런 함수들이 많이 존재한다)
			
			하지만 될수있으면 해주는 것이 좋다.
-----------------------------------------------------------------------------------------------------------------------------------------------
Object 클래스
	==> 자바로 만든 클래스의 최상위 클래스 역활을 하는 클래스
		솔직히 말해 하는일은 별로 없고
		자바 상속 관계를 명확하게 하기 위한 역활을 주로 하는 클래스
	
	1.equals()
		==> 비교 함수이다.
			문제는 Object가 가지고 있는 이함수는 
			내용을 비교하는 함수가 아니고
			주소를 비교하는 함수이다.
	
	참고 ]
		우리가 String 클래스의 equals 함수를 사용해서 문자열 데이터를 비교를 해서
		이 함수를 내용 비교함수로 알고있는데
		이것은 String 클래스가 Object 클래스의 equals 함수를 오버라이드해서
		기능을 내용 비교로 변경시켜서 사용하는 함수로 만들어 놓은 것이다.
		따라서 
			object.equals() 와 String.equals()의 차이점은 명확하게 구분해야 할 것이다.
			
		참고 ] 
			만약 우리가 만드는 클래스도 내용 비교를 하도록 원하면
			이 함수를 오버라이드해서 기능을 수정하면 될 것이다.
--------------------------------------------------------------------------------------------------------------------------------------------
문제 2 ]
	삼각형 클래스를 작성하고
	
	삼각형 클래스의 밑변과 높이를 입력해서 객체를 만들도록 작성하고
	
	만약 밑변이 같으면 같은 삼각형이 되도록 
	equals 함수, toSting()를 오버라이드하고
	테스트 하세요.
	
	입력은 JOtionPane소속의 함수로 처리하고 
	출력도 같은 소속의 함수로 처리하세요.
	추가로 예외 처리도 해주세요.